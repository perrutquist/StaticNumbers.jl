<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · StaticNumbers</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="StaticNumbers logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">StaticNumbers</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../reference/">Functions</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Fibonacci-numbers"><span>Fibonacci numbers</span></a></li><li><a class="tocitem" href="#The-Ackermann-function"><span>The Ackermann function</span></a></li><li><a class="tocitem" href="#Fast-multiplication-of-small-matrices."><span>Fast multiplication of small matrices.</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/perrutquist/StaticNumbers.jl/blob/master/docs/src/example.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>Here are a couple of examples of how StaticNumbers can be used.</p><h2 id="Fibonacci-numbers"><a class="docs-heading-anchor" href="#Fibonacci-numbers">Fibonacci numbers</a><a id="Fibonacci-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Fibonacci-numbers" title="Permalink"></a></h2><p>We can abuse static numbers to make the compiler compute the 20:th Fibonacci number:</p><pre><code class="nohighlight hljs">julia&gt; using StaticNumbers

julia&gt; fib(n) = n &lt;= 1 ? n : fib(static(n-1)) + fib(static(n-2))
fib (generic function with 1 method)

julia&gt; @code_llvm fib(static(20))

;  @ none:1 within `fib&#39;
define i64 @julia_fib_12331() {
top:
  ret i64 6765
}</code></pre><p>We see that the compiler has created a function that simply returns the 20th Fibonacci number (6765) without doing any run-time calculation at all. (In the process, the compiler builds a <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a> table of the first 20 Fibonacci numbers as part of the dispatch table.)</p><h2 id="The-Ackermann-function"><a class="docs-heading-anchor" href="#The-Ackermann-function">The Ackermann function</a><a id="The-Ackermann-function-1"></a><a class="docs-heading-anchor-permalink" href="#The-Ackermann-function" title="Permalink"></a></h2><p>A similar example is the <a href="https://en.wikipedia.org/wiki/Ackermann_function">Ackermann function</a>. We can make the first argument, <code>m</code>, a static number without causing a large number of mehtods to be compiled, since <code>m</code> is rarely larger@ than 5. (Otherwise the computation would take forever.)</p><pre><code class="nohighlight hljs">using StaticNumbers
function A(m,n)
    if iszero(m)
        n + one(n)
    elseif iszero(n)
        A(@stat(m - one(m)), one(n))
    else
        A(@stat(m - one(m)), A(m, n - one(n)))
    end
end
@time A(4, 1)
@time A(static(4), 1) # much faster</code></pre><p>The function <code>A</code> above also works when <code>m</code> is a regular <code>Int</code>, but the use of static numbers makes it significantly faster, even on the first call where compile time is also included.</p><h2 id="Fast-multiplication-of-small-matrices."><a class="docs-heading-anchor" href="#Fast-multiplication-of-small-matrices.">Fast multiplication of small matrices.</a><a id="Fast-multiplication-of-small-matrices.-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-multiplication-of-small-matrices." title="Permalink"></a></h2><p>As a more complicated example, we&#39;ll look at how static numbers together with generators and recursive functions to make highly specialized code (without having to use <code>@generated</code> functions).</p><p>The following example is based on <a href="http://kristofferc.github.io/post/intrinsics/">this blog post</a> describing how to use <a href="https://github.com/eschnett/SIMD.jl">SIMD.jl</a> to multiply 3-by-3 matrices even faster than what <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a> does. We want to generalize that example to arbitrary (but small) matrix sizes.</p><p>Note: For matrix sizes other than 3x3, this example currenlty requres Julia with <a href="https://github.com/JuliaLang/julia/pull/34473">#34473</a> and <a href="https://github.com/JuliaLang/julia/pull/34490">#34490</a>. These are in the latest nightly builds (1.5.0-DEV.206 and later) and hopefully they will also be in 1.4.0 when it is released.</p><p>We start by defining the type <code>Mat</code>, which we&#39;ll use to hold our matrices, plus a few methods are needed to make <code>Mat</code> display and convert to other matrix types:</p><pre><code class="language-julia hljs">using StaticNumbers
using SIMD
import Base: size, getindex, IndexStyle
StaticNumbers.@glue_to SIMD

struct Mat{T,M,N} &lt;: AbstractMatrix{T}
    data::NTuple{N,Vec{M,T}}
end

@inline size(::Mat{&lt;:Any,M,N}) where {M,N} = (static(M), static(N))
Base.@propagate_inbounds getindex(A::Mat, i::Integer, j::Integer) = A.data[j][i]
@inline IndexStyle(::Type{&lt;:Mat}) = IndexCartesian()</code></pre><p>So far, the only use of StaticNumbers is in the <code>size</code> function. Because the size is returned as static numbers, the <code>axes</code> of a <code>Mat</code> will automatically become <code>StaticOneTo</code> ranges, wich is a special case of the static-length range types provided by StaticNumbers.</p><p>In constructing a <code>Mat</code> from another matrix, we use generators over static ranges:</p><pre><code class="language-julia hljs">@inline function (::Type{T})(A::AbstractMatrix) where {T&lt;:Mat}
    T(Tuple(Vec(@inbounds(A[i,j]) for i in static(axes(A,1))) for j in static(axes(A,2))))
end</code></pre><p>(StaticNumbers provide special constructors for the <code>Tuple</code> and <code>Vec</code> types that utilize these generators.)</p><p>We are using the <code>@inline</code> directive on every function that we create, since in this example we want to force the compiler to do as much work as possible. (The user must avoid creating too large matrcies with the <code>Mat</code> type, or there will be trouble.) It is worth pointing out that Julia will go to extreme lengths to honor the <code>@inline</code> directive, as long as all type signatures are concrete. This can be used to &quot;unroll loops&quot; by doing tail recursion on <code>Tuple</code>s. For example with the following following function to compute the inner product of two tuples, Julia will generate explicit code for each tuple length that is encountered.</p><pre><code class="language-julia hljs">using Base: tail
@inline function inner(A::Tuple{Any}, B::Tuple{Any})
    first(A)*first(B)
end
@inline function inner(A::Tuple{Any,Vararg{Any}}, B::Tuple{Any,Vararg{Any}})
    muladd(first(A), first(B), inner(tail(A), tail(B)))
end</code></pre><p>With this function in place, the actual matrix multiplicaion is done in just one line:</p><pre><code class="language-julia hljs">@inline function Base.:*(A::Mat, B::AbstractMatrix)
    Mat(Tuple(inner(A.data, Tuple(@inbounds(B[k,j]) for k in axes(A,2))) for j in static(axes(B,2))))
end</code></pre><p>Again, we are using generators over static ranges to create <code>Tuple</code>s in a way that is similar to what we&#39;d get if we wrote a <code>@generated</code> function. (We are leaving out some the size checks here for brevity, but those would otherwise get optimized out by the compiler in the below benchmarks.)</p><pre><code class="language-julia hljs">julia&gt; using BenchmarkTools, StaticArrays

julia&gt; s = Ref(rand(SMatrix{3,3}))

julia&gt; m = Ref(Mat(rand(3,3)))

julia&gt; @btime $(s)[] * $(s)[];
  7.785 ns (0 allocations: 0 bytes)

julia&gt; @btime $(m)[] * $(m)[];
  3.364 ns (0 allocations: 0 bytes)</code></pre><p>This comparison is a bit unfair, because <code>SMatrix</code> and <code>Mat</code> have different memory layouts. In a <code>Mat</code>, there is padding so that each length-3 column vector is stored in 4 bytes for aligned loading into registeres. In order to make an appples-to-apples comparison, we should start and end with an <code>SMatrix</code>.</p><pre><code class="language-julia hljs">julia&gt; @inline mul_as_Mat(A, B) = SMatrix{size(A,1), size(B,2)}(Mat(A) * Mat(B));

julia&gt; @btime mul_as_Mat($(s)[], $(s)[]);
  3.366 ns (0 allocations: 0 bytes)</code></pre><p>The Julia and LLVM compilers are doing an amazing job here, optimzing the constructors for <code>Mat</code> and <code>SMatrix</code>, both of which are written to accept an <code>AbstractArray</code>. We could start from any other matrix type, as long as the compiler is able to figure out the size statically. For example, let&#39;s try a <code>view</code> where the length of each axis is static.</p><pre><code class="language-julia hljs">julia&gt; v = view(rand(7,11), range(5, length=static(3)), range(9, length=static(3)));

julia&gt; @btime mul_as_Mat($v, $v);
9.628 ns (0 allocations: 0 bytes)</code></pre><p>This is a bit slower (probably because loading data from a view involves calculating offsets based on the stride of the underlying matrix) but still this is an impressive result given that we did not write any spacialized code for views.</p><p>Footnote: Our example uses the same type of vectorization regardless of the matrix sizes, which is of course not optimal. (A 1x4 matrix is far better represented as one length-4 vector than 4 length-1 vectors, for example.) A more advanced <code>*</code> function would use a cost model to select the vectorization that works best for the sizes involved, like <a href="https://github.com/chriselrod/LoopVectorization.jl">LoopVectorization</a> does.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reference/">« Functions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Monday 11 April 2022 11:47">Monday 11 April 2022</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
