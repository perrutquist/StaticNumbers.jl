var documenterSearchIndex = {"docs":
[{"location":"reference/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"reference/","page":"Functions","title":"Functions","text":"CurrentModule = StaticNumbers","category":"page"},{"location":"reference/","page":"Functions","title":"Functions","text":"Static\nstatic\nunstatic\nStaticBool\nStaticInteger\nStaticReal\nStaticNumber\nStaticOrInt\nStaticOrBool\n@generate_static_methods","category":"page"},{"location":"reference/#StaticNumbers.Static","page":"Functions","title":"StaticNumbers.Static","text":"Static{X} is short-hand for the Union of StaticInteger{X}, StaticReal{X} and StaticNumber{X}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StaticNumbers.static","page":"Functions","title":"StaticNumbers.static","text":"static(X) is shorthand for StaticInteger{X}(), StaticReal{X}() or StaticNumber{X}(), depending on the type of X.\n\n\n\n\n\nstatic(range) converts to a range where all aspects are Static.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StaticNumbers.unstatic","page":"Functions","title":"StaticNumbers.unstatic","text":"unstatic(x) returns a non-static version of x. This function is rarely needed, as most operations on a static number (e.g. x+0) will yield a non-static result.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StaticNumbers.StaticBool","page":"Functions","title":"StaticNumbers.StaticBool","text":"StaticBool is a shorthand for Union{StaticInteger{false}, StaticInteger{true}}\n\n\n\n\n\n","category":"type"},{"location":"reference/#StaticNumbers.StaticInteger","page":"Functions","title":"StaticNumbers.StaticInteger","text":"A StaticInteger is an Integer whose value is stored in the type, and which contains no runtime data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StaticNumbers.StaticReal","page":"Functions","title":"StaticNumbers.StaticReal","text":"A StaticReal is a Real whose value is stored in the type, and which contains no runtime data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StaticNumbers.StaticNumber","page":"Functions","title":"StaticNumbers.StaticNumber","text":"A StaticNumber is a Number whose value is stored in the type, and which contains no runtime data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StaticNumbers.StaticOrInt","page":"Functions","title":"StaticNumbers.StaticOrInt","text":"StaticOrInt is the type union of Int and StaticInteger\n\n(Functions that take only Int may be too restrictive.)\n\n\n\n\n\n","category":"type"},{"location":"reference/#StaticNumbers.StaticOrBool","page":"Functions","title":"StaticNumbers.StaticOrBool","text":"StaticOrBool can be either a Bool or a StaticBool\n\n\n\n\n\n","category":"type"},{"location":"reference/#StaticNumbers.@generate_static_methods","page":"Functions","title":"StaticNumbers.@generate_static_methods","text":"@generate_static_methods numbers 1argfuns 2argfuns\n\nThis macro creates methods that return Static numbers when functions are called with only Static arguments.\n\nThe inputs should be a list of literal numbers that will be tested as inputs and outputs of all functions.\n\nOptionally a fourth argument can give a list of numbers that will only be considered as results, but not as inputs.\n\nExample:\n\n@generate_static_methods (0, 1) (sin, cos) (+, -)\n\nwill create all the following method definitions:\n\nsin(::StaticInteger{0}) = StaticInteger{0}()\ncos(::StaticInteger{0}) = StaticInteger{1}()\n+(::StaticInteger{0}, ::StaticInteger{0}) = StaticInteger{0}()\n+(::StaticInteger{0}, ::StaticInteger{1}) = StaticInteger{1}()\n+(::StaticInteger{1}, ::StaticInteger{0}) = StaticInteger{1}()\n-(::StaticInteger{0}, ::StaticInteger{0}) = StaticInteger{0}()\n-(::StaticInteger{1}, ::StaticInteger{0}) = StaticInteger{0}()\n-(::StaticInteger{1}, ::StaticInteger{1}) = StaticInteger{1}()\n\n(Note: The macro will run in the local scope. Functions from Base must be imported before they can be extended.)\n\n\n\n\n\n","category":"macro"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides number datatypes which store their data in a type parameter. These are referred to as static numbers. (The word \"static\" has lots of uses in computer science. Here, it means that the number is constant at runtime.)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Data that is passed in type parameters is (usually) handled at compile-time, rather than at run-time. In certain cases this can lead to better performance. For this reason, some functions accept value type arguments, Val{X}, where X is an argument that is passed at compile-time. Static is an alternative to Val which is specifically designed to handle numbers.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The difference between Val and Static is that Static types promote and convert like their type parameters, so they can be used directly in arithmetic operations. (For example static(1) + 1 equals 2.) This makes it possible to use them with functions that were not specifically written to accept value arguments, essentially forcing the Julia compiler to do constant propagation in situations where it might not otherwise have done so.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Under the surface, there are three Static datatypes: StaticInteger, StaticReal, and StaticNumber, subtypes of Integer, Real and Number respectively. The Union type Static can be used to refer to them all. For brevity, all three types are displayed as static(X), and it is also recommended to create them using this syntax.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note: At the moment, the type union is named Static with a capital S, while the function that creates static variables is named static in lowercase.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"By default, any operation on a Static will result in a non-Static type. For example, static(2)+static(2) gives 4, not static(4).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The macro @stat makes the result of a computation a Static when all arguments are static or literals. For example:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"i = 2\ns = static(2)\ns + s        # returns 4 - not static(4), even though s is static.\n@stat s + s  # returns static(4)\n@stat s + 2  # also returns static(4), since 2 is a literal\n@stat s + i  # returns 4, because i is not a static number","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If the @stat macro is used with pure (and relatively simple) functions, then the Julia compiler will be able to infer the return type, resulting in performant code.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Static numbers can be used to create ranges with static length. Such ranges can be used to create tuples in an efficient manner. For example:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Tuple(i^2 for i in static(1):static(4)) # computed at compile time\nTuple(i^2 for i in 1:4) # computed at runtime, length of the tuple is not inferred (as of Julia 1.3.1).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Indexing into tuples can also be a lot more efficient with static numbers. For example:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"t = (1, 2, 3, 4)\n@stat t[2:end-1] # fast, type stable and non-allocating\nt[2:end-1] # less performant","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Indexing tuples without static numbers works well in certain special cases, thanks to pull request 31138.)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"When creating static numbers, it is important to consider whether the type system will be able to work efficiently. For example, f(static(x), y) is likely slower than f(x, y) even when called repeatedly with the same x. A specialized method of f is created for this value of x, and the function call itself will be faster. But since the type system will not know the type of static(x) in advance, a dynamic dispatch will happen at each function call.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"On the other hand, something like f(x==0 ? static(0) : x, y) will typically be fast. The construct x==0 ? static(0) : x will belong to Union{typeof(x), static(0)}, and Julia is able to dispatch efficiently on small type unions. Shorthands for this construct are f(trystatic(x, 0), y) and f(x â©¢ 0, y).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is important not to make the set of static numbers (i.e. types) too large, as this can lead to a lot of compilation overhead. The @stat macro can be dangerous when used inside loops or in recursive functions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There is no StaticRational datatype, but a StaticReal with a Rational type parameter will convert and promote like its parameter. For example: static(1//2) + 1 === 3//2.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The Unsigned datatype currently does not work well with static numbers. For this reason  the @stat macro does not turn unsigned numbers into static. (This is work in progress, and subjec to change.)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Static numbers are only fast when fully specified. A Vector{Static} is much slower than a Vector{Int}. (A Vector{StaticInteger{1}} is fast and requires very little memory, but on the other hand it can only store the number one.)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Source code on GitHub","category":"page"},{"location":"example/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Here are a couple of examples of how StaticNumbers can be used.","category":"page"},{"location":"example/#Fibonacci-numbers","page":"Examples","title":"Fibonacci numbers","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"We can abuse static numbers to make the compiler compute the 20:th Fibonacci number:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"julia> using StaticNumbers\n\njulia> fib(n) = n <= 1 ? n : fib(static(n-1)) + fib(static(n-2))\nfib (generic function with 1 method)\n\njulia> @code_llvm fib(static(20))\n\n;  @ none:1 within `fib'\ndefine i64 @julia_fib_12331() {\ntop:\n  ret i64 6765\n}","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We see that the compiler has created a function that simply returns the 20th Fibonacci number (6765) without doing any run-time calculation at all. (In the process, the compiler builds a memoization table of the first 20 Fibonacci numbers as part of the dispatch table.)","category":"page"},{"location":"example/#The-Ackermann-function","page":"Examples","title":"The Ackermann function","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"A similar example is the Ackermann function. We can make the first argument, m, a static number without causing a large number of mehtods to be compiled, since m is rarely larger@ than 5. (Otherwise the computation would take forever.)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using StaticNumbers\nfunction A(m,n)\n    if iszero(m)\n        n + one(n)\n    elseif iszero(n)\n        A(@stat(m - one(m)), one(n))\n    else\n        A(@stat(m - one(m)), A(m, n - one(n)))\n    end\nend\n@time A(4, 1)\n@time A(static(4), 1) # much faster","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The function A above also works when m is a regular Int, but the use of static numbers makes it significantly faster, even on the first call where compile time is also included.","category":"page"},{"location":"example/#Fast-multiplication-of-small-matrices.","page":"Examples","title":"Fast multiplication of small matrices.","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"As a more complicated example, we'll look at how static numbers together with generators and recursive functions to make highly specialized code (without having to use @generated functions).","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The following example is based on this blog post describing how to use SIMD.jl to multiply 3-by-3 matrices even faster than what StaticArrays.jl does. We want to generalize that example to arbitrary (but small) matrix sizes.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Note: For matrix sizes other than 3x3, this example currenlty requres Julia with #34473 and #34490. These are in the latest nightly builds (1.5.0-DEV.206 and later) and hopefully they will also be in 1.4.0 when it is released.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We start by defining the type Mat, which we'll use to hold our matrices, plus a few methods are needed to make Mat display and convert to other matrix types:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using StaticNumbers\nusing SIMD\nimport Base: size, getindex, IndexStyle\nStaticNumbers.@glue_to SIMD\n\nstruct Mat{T,M,N} <: AbstractMatrix{T}\n    data::NTuple{N,Vec{M,T}}\nend\n\n@inline size(::Mat{<:Any,M,N}) where {M,N} = (static(M), static(N))\nBase.@propagate_inbounds getindex(A::Mat, i::Integer, j::Integer) = A.data[j][i]\n@inline IndexStyle(::Type{<:Mat}) = IndexCartesian()","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"So far, the only use of StaticNumbers is in the size function. Because the size is returned as static numbers, the axes of a Mat will automatically become StaticOneTo ranges, wich is a special case of the static-length range types provided by StaticNumbers.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"In constructing a Mat from another matrix, we use generators over static ranges:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"@inline function (::Type{T})(A::AbstractMatrix) where {T<:Mat}\n    T(Tuple(Vec(@inbounds(A[i,j]) for i in static(axes(A,1))) for j in static(axes(A,2))))\nend","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"(StaticNumbers provide special constructors for the Tuple and Vec types that utilize these generators.)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We are using the @inline directive on every function that we create, since in this example we want to force the compiler to do as much work as possible. (The user must avoid creating too large matrcies with the Mat type, or there will be trouble.) It is worth pointing out that Julia will go to extreme lengths to honor the @inline directive, as long as all type signatures are concrete. This can be used to \"unroll loops\" by doing tail recursion on Tuples. For example with the following following function to compute the inner product of two tuples, Julia will generate explicit code for each tuple length that is encountered.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using Base: tail\n@inline function inner(A::Tuple{Any}, B::Tuple{Any})\n    first(A)*first(B)\nend\n@inline function inner(A::Tuple{Any,Vararg{Any}}, B::Tuple{Any,Vararg{Any}})\n    muladd(first(A), first(B), inner(tail(A), tail(B)))\nend","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"With this function in place, the actual matrix multiplicaion is done in just one line:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"@inline function Base.:*(A::Mat, B::AbstractMatrix)\n    Mat(Tuple(inner(A.data, Tuple(@inbounds(B[k,j]) for k in axes(A,2))) for j in static(axes(B,2))))\nend","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Again, we are using generators over static ranges to create Tuples in a way that is similar to what we'd get if we wrote a @generated function. (We are leaving out some the size checks here for brevity, but those would otherwise get optimized out by the compiler in the below benchmarks.)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"julia> using BenchmarkTools, StaticArrays\n\njulia> s = Ref(rand(SMatrix{3,3}))\n\njulia> m = Ref(Mat(rand(3,3)))\n\njulia> @btime $(s)[] * $(s)[];\n  7.785 ns (0 allocations: 0 bytes)\n\njulia> @btime $(m)[] * $(m)[];\n  3.364 ns (0 allocations: 0 bytes)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"This comparison is a bit unfair, because SMatrix and Mat have different memory layouts. In a Mat, there is padding so that each length-3 column vector is stored in 4 bytes for aligned loading into registeres. In order to make an appples-to-apples comparison, we should start and end with an SMatrix.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"julia> @inline mul_as_Mat(A, B) = SMatrix{size(A,1), size(B,2)}(Mat(A) * Mat(B));\n\njulia> @btime mul_as_Mat($(s)[], $(s)[]);\n  3.366 ns (0 allocations: 0 bytes)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The Julia and LLVM compilers are doing an amazing job here, optimzing the constructors for Mat and SMatrix, both of which are written to accept an AbstractArray. We could start from any other matrix type, as long as the compiler is able to figure out the size statically. For example, let's try a view where the length of each axis is static.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"julia> v = view(rand(7,11), range(5, length=static(3)), range(9, length=static(3)));\n\njulia> @btime mul_as_Mat($v, $v);\n9.628 ns (0 allocations: 0 bytes)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"This is a bit slower (probably because loading data from a view involves calculating offsets based on the stride of the underlying matrix) but still this is an impressive result given that we did not write any spacialized code for views.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Footnote: Our example uses the same type of vectorization regardless of the matrix sizes, which is of course not optimal. (A 1x4 matrix is far better represented as one length-4 vector than 4 length-1 vectors, for example.) A more advanced * function would use a cost model to select the vectorization that works best for the sizes involved, like LoopVectorization does.","category":"page"}]
}
